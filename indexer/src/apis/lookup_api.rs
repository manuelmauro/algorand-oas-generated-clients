/*
 * Indexer
 *
 * Algorand ledger analytics API.
 *
 * The version of the OpenAPI document: 2.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `lookup_account_by_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupAccountByIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `lookup_account_transactions`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupAccountTransactionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `lookup_application_by_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupApplicationByIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `lookup_asset_balances`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupAssetBalancesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `lookup_asset_by_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupAssetByIdError {
    Status404(crate::models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `lookup_asset_transactions`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupAssetTransactionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `lookup_block`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupBlockError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `lookup_transaction`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupTransactionError {
    Status404(crate::models::ErrorResponse),
    Status500(crate::models::ErrorResponse),
    UnknownValue(serde_json::Value),
}


/// Lookup account information.
pub async fn lookup_account_by_id(configuration: &configuration::Configuration, account_id: &str, round: Option<i32>, include_all: Option<bool>) -> Result<crate::models::InlineResponse2001, Error<LookupAccountByIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v2/accounts/{account-id}", configuration.base_path, account-id=crate::apis::urlencode(account_id));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = round {
        local_var_req_builder = local_var_req_builder.query(&[("round", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_all {
        local_var_req_builder = local_var_req_builder.query(&[("include-all", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LookupAccountByIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lookup account transactions.
pub async fn lookup_account_transactions(configuration: &configuration::Configuration, account_id: &str, limit: Option<i32>, next: Option<&str>, note_prefix: Option<&str>, tx_type: Option<&str>, sig_type: Option<&str>, txid: Option<&str>, round: Option<i32>, min_round: Option<i32>, max_round: Option<i32>, asset_id: Option<i32>, before_time: Option<String>, after_time: Option<String>, currency_greater_than: Option<i32>, currency_less_than: Option<i32>, rekey_to: Option<bool>) -> Result<crate::models::InlineResponse2002, Error<LookupAccountTransactionsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v2/accounts/{account-id}/transactions", configuration.base_path, account-id=crate::apis::urlencode(account_id));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = next {
        local_var_req_builder = local_var_req_builder.query(&[("next", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = note_prefix {
        local_var_req_builder = local_var_req_builder.query(&[("note-prefix", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = tx_type {
        local_var_req_builder = local_var_req_builder.query(&[("tx-type", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sig_type {
        local_var_req_builder = local_var_req_builder.query(&[("sig-type", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = txid {
        local_var_req_builder = local_var_req_builder.query(&[("txid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = round {
        local_var_req_builder = local_var_req_builder.query(&[("round", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_round {
        local_var_req_builder = local_var_req_builder.query(&[("min-round", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_round {
        local_var_req_builder = local_var_req_builder.query(&[("max-round", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = asset_id {
        local_var_req_builder = local_var_req_builder.query(&[("asset-id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = before_time {
        local_var_req_builder = local_var_req_builder.query(&[("before-time", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = after_time {
        local_var_req_builder = local_var_req_builder.query(&[("after-time", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = currency_greater_than {
        local_var_req_builder = local_var_req_builder.query(&[("currency-greater-than", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = currency_less_than {
        local_var_req_builder = local_var_req_builder.query(&[("currency-less-than", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = rekey_to {
        local_var_req_builder = local_var_req_builder.query(&[("rekey-to", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LookupAccountTransactionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lookup application.
pub async fn lookup_application_by_id(configuration: &configuration::Configuration, application_id: i32, include_all: Option<bool>) -> Result<crate::models::InlineResponse2004, Error<LookupApplicationByIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v2/applications/{application-id}", configuration.base_path, application-id=application_id);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = include_all {
        local_var_req_builder = local_var_req_builder.query(&[("include-all", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LookupApplicationByIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lookup the list of accounts who hold this asset 
pub async fn lookup_asset_balances(configuration: &configuration::Configuration, asset_id: i32, include_all: Option<bool>, limit: Option<i32>, next: Option<&str>, round: Option<i32>, currency_greater_than: Option<i32>, currency_less_than: Option<i32>) -> Result<crate::models::InlineResponse2007, Error<LookupAssetBalancesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v2/assets/{asset-id}/balances", configuration.base_path, asset-id=asset_id);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = include_all {
        local_var_req_builder = local_var_req_builder.query(&[("include-all", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = next {
        local_var_req_builder = local_var_req_builder.query(&[("next", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = round {
        local_var_req_builder = local_var_req_builder.query(&[("round", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = currency_greater_than {
        local_var_req_builder = local_var_req_builder.query(&[("currency-greater-than", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = currency_less_than {
        local_var_req_builder = local_var_req_builder.query(&[("currency-less-than", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LookupAssetBalancesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lookup asset information.
pub async fn lookup_asset_by_id(configuration: &configuration::Configuration, asset_id: i32, include_all: Option<bool>) -> Result<crate::models::InlineResponse2006, Error<LookupAssetByIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v2/assets/{asset-id}", configuration.base_path, asset-id=asset_id);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = include_all {
        local_var_req_builder = local_var_req_builder.query(&[("include-all", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LookupAssetByIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lookup transactions for an asset.
pub async fn lookup_asset_transactions(configuration: &configuration::Configuration, asset_id: i32, limit: Option<i32>, next: Option<&str>, note_prefix: Option<&str>, tx_type: Option<&str>, sig_type: Option<&str>, txid: Option<&str>, round: Option<i32>, min_round: Option<i32>, max_round: Option<i32>, before_time: Option<String>, after_time: Option<String>, currency_greater_than: Option<i32>, currency_less_than: Option<i32>, address: Option<&str>, address_role: Option<&str>, exclude_close_to: Option<bool>, rekey_to: Option<bool>) -> Result<crate::models::InlineResponse2002, Error<LookupAssetTransactionsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v2/assets/{asset-id}/transactions", configuration.base_path, asset-id=asset_id);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = next {
        local_var_req_builder = local_var_req_builder.query(&[("next", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = note_prefix {
        local_var_req_builder = local_var_req_builder.query(&[("note-prefix", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = tx_type {
        local_var_req_builder = local_var_req_builder.query(&[("tx-type", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sig_type {
        local_var_req_builder = local_var_req_builder.query(&[("sig-type", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = txid {
        local_var_req_builder = local_var_req_builder.query(&[("txid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = round {
        local_var_req_builder = local_var_req_builder.query(&[("round", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_round {
        local_var_req_builder = local_var_req_builder.query(&[("min-round", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_round {
        local_var_req_builder = local_var_req_builder.query(&[("max-round", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = before_time {
        local_var_req_builder = local_var_req_builder.query(&[("before-time", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = after_time {
        local_var_req_builder = local_var_req_builder.query(&[("after-time", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = currency_greater_than {
        local_var_req_builder = local_var_req_builder.query(&[("currency-greater-than", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = currency_less_than {
        local_var_req_builder = local_var_req_builder.query(&[("currency-less-than", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = address {
        local_var_req_builder = local_var_req_builder.query(&[("address", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = address_role {
        local_var_req_builder = local_var_req_builder.query(&[("address-role", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_close_to {
        local_var_req_builder = local_var_req_builder.query(&[("exclude-close-to", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = rekey_to {
        local_var_req_builder = local_var_req_builder.query(&[("rekey-to", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LookupAssetTransactionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lookup block.
pub async fn lookup_block(configuration: &configuration::Configuration, round_number: i32) -> Result<crate::models::Block, Error<LookupBlockError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v2/blocks/{round-number}", configuration.base_path, round-number=round_number);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LookupBlockError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lookup a single transaction.
pub async fn lookup_transaction(configuration: &configuration::Configuration, txid: &str) -> Result<crate::models::InlineResponse2008, Error<LookupTransactionError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v2/transactions/{txid}", configuration.base_path, txid=crate::apis::urlencode(txid));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LookupTransactionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

